%! TeX program = xelatex
%! TEX TS-program = xelatex
\documentclass[11pt,a4paper]{article}

% Language
\usepackage{polyglossia}
\setdefaultlanguage[frenchpart=false, frenchfootnote=true, frenchitemlabels=true]{french}
\usepackage{numprint}

% Fonts
\usepackage{fontspec}
\setmainfont{Linux Libertine O}
\setsansfont{Linux Biolinum O}
% \setmonofont{Linux Libertine Mono O}

\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{attachfile2}

\usepackage{fullpage}
\usepackage[parfill]{parskip}

\usepackage{xcolor}

%-----------------------------------------------------------

\newcommand{\up}[1]{\textsuperscript{#1}}
\newcommand{\down}[1]{\textsubscript{#1}}

\newcommand{\addcode}[3]{
	\begin{center}
		\lstinputlisting[language=#2, caption=\textattachfile{#1}{#1}, label=#3]{#1}
	\end{center}
}

\newcommand{\addimg}[4]{
	\begin{figure}[H]
		\centering
		\includegraphics[#2]{#1}
	\caption{#3}
	\label{#4}
	\end{figure}
}

\newcommand{\p}[1]{(p #1)}
\newcommand{\e}[2]{#1 \p{#2}}

%-----------------------------------------------------------

\definecolor{base}{RGB}{250,245,237}
\definecolor{subtle}{RGB}{110,107,135}
\definecolor{love}{RGB}{181,99,122}
\definecolor{gold}{RGB}{235,158,51}
\definecolor{rose}{RGB}{214,130,125}
\definecolor{pine}{RGB}{41,105,130}
\definecolor{foam}{RGB}{87,148,158}
\definecolor{iris}{RGB}{143,122,168}

\hypersetup{
	colorlinks=true,
		allcolors=iris
}
\attachfilesetup{color=iris}

%-----------------------------------------------------------

\lstset{
	% backgroundcolor=\color{white},        % background color
		basicstyle=\ttfamily,                   % regular style
		breakatwhitespace=true,                 % sets if automatic breaks should only happen at whitespace
		breaklines=true,                        % sets automatic line breaking
		captionpos=t,                           % caption-position
		commentstyle=\itshape\color{subtle},    % comment style
		% deletekeywords={...},                 % delete keywords from the given language
		escapeinside={\%*}{*)},                 % if you want to add LaTeX within your code
		firstnumber=1,                          % start line enumeration with line 1
		frame=tb,                               % adds a frame around the code
		keepspaces=true,                        % keeps spaces in text
		keywordstyle=\color{pine},              % keyword style
		language=C++,                           % language of the code
		% morekeywords={*,...},                 % add more keywords to the set
		numbers=left,                           % position of line-numbers; possible values are (none, left, right)
		numbersep=15pt,                         % distance between line-numbers and the code
		numberstyle=\scriptsize\ttfamily\color{subtle}, % style used for line-numbers
		% rulecolor=\color{black},              % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
		showspaces=false,                       % show spaces everywhere
		showstringspaces=false,                 % underline spaces within strings only
		showtabs=false,                         % show tabs within strings
		stepnumber=1,                           % step between two line-numbers
		stringstyle=\color{love},               % string literal style
		tabsize=4,	                          % default tabsize
		% title=\lstname                        % show the filename
}

%-----------------------------------------------------------

\title{Polygon Crush Saga}
\author{Alec Weinhofer \and Boris Petrov}
\date{\today}

\begin{document}
\maketitle
\tableofcontents

%-----------------------------------------------------------

\section{Introduction}

\emph{Candy Crush Saga}\footnote{\url{https://fr.wikipedia.org/wiki/Candy_Crush_Saga}}
cumule à ce jour plus de 2,7 milliards de
téléchargements. Un nombre faramineux. Cela le rend de fait
un des jeux les plus populaires de ces dernières années et
ce n'est évidemment pas dû au hasard. Derrière ce titre, se
cache un concept simple mais intelligent qui consiste à
former des combinaisons de bonbons pour les faire
disparaître afin de remplir des objectifs divers.

C'est donc ce concept simple sur papier (mais pas tellement
dans les faits) que nous avons essayé de répliquer pour ce
projet en utilisant des concepts d'orienté objet tels que
l'encapsulation ou encore l'héritage.

Pour ce qui est du rapport, nous allons d'abord commencer par donner un aperçu des
fonctionnalités que nous avons réussi à implémenter avant de
rentrer dans les détails d'implémentation.
Nous aborderons ensuite le calcul de notre score.

\section{Fonctionnalités}

\subsection{Fonctionnalités de base}
Commençons donc par faire le tour des fonctionnalités basique que notre jeu propose.
À son lancement, le jeu nous propose de choisir parmi neuf niveaux différents.
Ces derniers sont de plus en plus intéressants et donc
aussi d'une difficulté accrue.

Ensuite, en entrant dans un niveau, nous tombons sur le plateau de jeu.
Il va de soi que nous avons les fonctionnalités de base de \emph{Candy Crush Saga},
c'est-à-dire les bonbons standards qui disparaissent en
formant des combinaisons de la même couleur. De plus, toute modification du plateau 
sera accompagnée d'une animation.

L'échange de deux bonbons peut se faire de deux manières différentes. Soit nous appuyons 
sur les deux bonbons en question, soit nous faisons glisser le premier vers son voisin.

\subsection{Fonctionnalités en jeu}

Si aucune action n'est possible, le jeu nous en fait part grâce à un petit 
message sur l'écran avant de remplacer tous les bonbons standards du plateau.

Si par contre vous ne savez pas quoi faire, pas d'inquiétude, le jeu vous proposera 
la meilleur action grâce à son système de suggestion.

Le glaçage, les fruits, les murs sont des éléments de jeu que nous proposons 
pour offrir une meilleur experience de jeu. Le glaçage se voit être détruit quand les bonbons 
autour de lui sont détruits. Pour ce qui est d'un fruit, il faudra le faire parvenir tout-en-bas du 
plateau afin de le faire disparraitre. Le glaçage et les fruits sont des objectifs, et doivent donc 
être détruits pour gagner le niveau.

Le programme nous permet de voir notre score en jeu.
Sur l'écran d'accueil nous pourrons appercevoir notre meilleur score. Nous pouvons ainsi 
tenter de battre le meilleur score qui sera enregistré, même après la fermeture du programme.

\subsection{Bonbons spéciaux}

Nous proposons aussi de former certains bonbons
spéciaux dans certaines conditions. En effet, comme dans le vrais jeu, 
il nous est possible de faire certaines combinaisons de bonbons afin de faire apparaitre
des bonbons rayés (ou \emph{stripped candy}), des bonbons emballés (ou \emph{wrapped candy}) 
ou encore des bombes de couleur (ou \emph{colour bomb}). Ces derniers exploseront de la 
même façon que dans \emph{Candy Crush Saga}.

Notre jeu propose, tout comme dans le jeu original, de créer des explosions
particulières quand deux bonbons spéciaux sont échangés. Vous touverez plus d'information 
à propos de ces échanges sur \emph{le wiki du jeu}\footnote{\url{https://candycrush.fandom.com/wiki/Candy_Crush_Saga_Wiki}}.


\section{Fonctionnalités non-implémentées}
Notre jeu implémente presque toutes les fonctionnalités
demandées.
La seule chose qu'il n'implémente pas est l'éditeur de niveau.
C'est principalement par manque de temps.

\section{Implémentation}
\subsection{Logique}
Voyons maintenant ce qu'il se passe précisement quand vous ouvrez le jeu, selectionnez un 
niveau et jouez un coup. A l'exécution du jeu, une instance de \emph{Game} ne tarde pas à se créer. 
A sa construction, elle fait une vérification de la sauvegarde du score, et ensuite crée une 
instance de \emph{SplashScreen}. Cette instance est donc responsable 
de l'écran de démarage que vous apercevez au lancement du jeu.

Ensuite, quand le timer de \emph{SplashScreen} se termine, ce dernier chargera une instance 
de \emph{LevelSelector}, qui sera contenue dans \emph{Game}. Cette instance affiche une 
sélection de niveaux. Quand vous sélectionnez un niveau, une fonction \emph{mouseClick()} 
est appelée par FLTK. Celle-ci est réecrite dans notre sélecteur de niveau pour pouvoir récupérer 
le numero de niveau de la case qu'on a choisie. Dès lors qu'on a ce numéro, le sélecteur 
peut charger le niveau en question dans \emph{Game}. Ainsi le niveau s'affiche, après une 
récupération des informations du niveau.

Maintenant que la grille de jeu est instanciée et prête, elle se met en attente d'une entrée 
utilisateur. C'est-à-dire qu'aucun code ne s'exécute tant que l'utilisateur n'effectue pas une action.
Quand l'utilisateur se décide à échanger deux bonbons, la grille vérifiera la validité de l'échange.
Si l'échange ne crée aucune combinaison, la grille re-échange les deux bonbons. Notons qu'un échange 
est suivi par l'exécution d'une animation (translation). 

Si par contre l'échange crée une conbinaison, un fonction \emph{clear()} sera appelée sur chaque 
bonbon composant la combinaison, et le plateau passe dans un état \emph{clearState}. Cette fonction 
s'occupe de faire disparaître les bonbons concernés, mais va aussi instancier une animation de disparition. 
Quand celle-ci est terminée, le plateau passe dans un état \emph{fallState} et des bonbons tomberont afin 
de remplir le plateau. Les deux états que j'ai mentionnés, représentent une phase où le plateau subit des 
modifications avec des animations. Ces états réécrivent les fonctions d'E/S utilisateur pour ne rien faire 
si elles sont appelées. Ainsi, cela permet de désactiver les actions de l'utilisateur pendant que le plateau 
fait ses modifications.

Pour finir, à la fin des modifications, le plateau repasse en \emph{readyState}, un état qui permet au 
joueur de jouer son coup.

\subsection{Classes}

Étant donné le grand nombre de classes de notre projet, nous
avons décidé de ne mettre que les plus importantes, celles
nécessaires pour bien comprendre le fonctionnement.

Nous avons également omis les méthodes intermédiaires
nécessaires pour recevoir une information d'un objet
\emph{C} depuis un objet \emph{B} telles que \verb@b.w()@ pour
éviter \verb@b.getWindow().w()@.

Pour ce qui est de la partie visuelle de notre jeu, nous
avons quelques classes de formes ainsi que des animations
qui peuvent leur être attachées. Celles-ci étant
principalement du code FLTK, nous avons décidé de ne pas les
inclure ici.

Les deux classes qui suivent sont la base de presque toutes
les autres classes de notre projet. Les héritiers de la
première sont interactifs et réagissent aux évènements
qu'ils implémentent alors que ceux de la deuxième peuvent
être dessinés sur l'écran. Cette dernière est une sorte conteneur d'une forme et
d'une éventuelle animation.

\addcode{code/interactive.hpp}{C++}{}{}
\addcode{code/drawableContainer.hpp}{C++}{}{}

Deux autres classes basiques, sont celles implémentant le
\emph{pattern} de l'observateur. Nous avons ainsi \verb@Observer@
et \verb@Subject@.

Nous avons ensuite la classe \verb@Game@ qui est le point
pivotant de notre programme. Elle décide quelle vue
afficher et contient le meilleur score.

Une vue dans notre programme est un écran que nous pouvons
avoir dans notre jeu. Ce sera par exemple l'écran de
chargement, le sélecteur de niveau ou encore un niveau
individuel (en exemple ci-dessous).

\addcode{code/game.hpp}{C++}{}{}

\addcode{code/view.hpp}{C++}{}{}
% \addcode{code/loadingScreen.hpp}{C++}{}{}
\addcode{code/level.hpp}{C++}{}{}
% \addcode{code/levelSelector.hpp}{C++}{}{}

Un niveau contient donc les données du niveau, une grille
et une barre de statut.

Les données sont stockées dans une instance de la classe
\verb@LevelData@. C'est en quelque sorte une classe
conteneur qui initialise ses données lors de sa construction
et possède des méthodes se limitant à des \emph{getters}.
Les données ne sont pas sensées être changées après la
construction. Elle n'est pas strictement nécessaire à la compréhension
du fonctionnement de notre programme.

La barre de statut est, quant à elle, plus intéressante.
Elle va se charger de deux aspects centraux de nos niveaux, le
comptage du score et l'objectif à atteindre.

Le score va être mis à jour lors de la réception de certains
évènements (\emph{cfr.} \ref{score}). L'attribution du score
à chaque évènement est fait par \verb@scoreValueOf()@ et mis
à jour avec \verb@updateScore()@.

\addcode{code/levelStatus.hpp}{C++}{}{}

\verb@LevelGoal@ est une classe abstraite extensible de \emph{but} que le
joueur peut atteindre. Dans notre cas, nous n'avons qu'une
seule implémentation, mais d'autres sont possibles (comme le
prouve le jeu original avec des buts de collection de
bonbons etc). 

\addcode{code/levelGoal.hpp}{C++}{}{}
\addcode{code/eventOccurGoal.hpp}{C++}{}{}

Enfin, abordons la grille, le cœur de notre programme.
Celle-ci n'est en réalité rien d'autre qu'une matrice de \verb@Cell@
et quelques fonctions qui permettent d'agir sur celles-ci.

\addcode{code/grid.hpp}{C++}{}{}

Les \verb@Cell@s sont quant à elles de simples plateformes
sur lesquelles peuvent résider des \verb@CellContent@.
Elles en sont propriétaires et peuvent par exemple les
animer, les supprimer ou encore échanger avec d'autres
\verb@Cell@.

\addcode{code/cell.hpp}{C++}{}{}

Pour compléter le plateau de jeu, nous avons aussi tout ce
qui peut aller sur les \verb@Cell@, c'est-à-dire les
\verb@CellContent@s. Ces derniers peuvent aussi bien être
des bonbons, des murs ou encore des fruits. Chacun ayant des
des propriétés bien particulières, nous avons aussi trois
sous-classes de \verb@CellContent@ qui définissent les
actions pouvant être faites sur les \verb@CellContent@.
Ainsi nous avons \verb@MovableCellContent@,
\verb@ClearableCellContent@ et \verb@MatchableCellContent@.
Les \verb@Fruit@ sont mis en exemple.

\addcode{code/cellContent.hpp}{C++}{}{}
\addcode{code/fruit.hpp}{C++}{}{}

Enfin nous avons la famille de classes la plus importante et
qui est pourtant invisible. C'est celle des états
(\verb@State@) dans lesquels peut être notre grille.
Ces derniers vont définir la manière de laquelle la grille
qu'ils contrôlent réagit face à certains évènements.
Les \verb@State@s seront expliqués plus en détail dans la
section \ref{mvc}.

\addcode{code/state.hpp}{C++}{}{}
\addcode{code/readyState.hpp}{C++}{}{}

% done interactive, drawableContainer, game, view, level, animation, shape, levelData, observer, point
% todo board_state



\subsection{MVC} \label{mvc}

Nous n'avons pas un architecture MVC en tant que telle, avec
les trois composants principaux, mais plutôt quelques éléments y
faisant référence.

Nous avons les états dans lesquels notre jeu
peut être. Le \verb@ReadyState@, par exemple, a
lieu lorsqu'une action est attendue de la part du joueur, là
où le \verb@FallState@ est actif lorsque des bonbons sont
en train de tomber.

Le propre de chaque état est de réagir de manière différente
aux évènements tels que les clics de souris ou encore la
terminaison des animations. Ainsi par exemple, les clics de souris ne devraient
pas être considérés lorsque deux bonbons sont en train
d'être échangés.

Nous pouvons d'une manière transposer les états du jeu aux Contrôleurs et la
grille qu'ils contrôlent à la Vue et au Modèle.
Cette implémentation boiteuse vient principalement du fait
que nous avions conçu notre architecture avant d'avoir vu le
concept de MVC et nous avons essayé de l'implémenter trop
tard.

\subsection{Score} \label{score}

Les calcul du score est, contrairement au jeu original, plutôt simple.
Il est mis à jour par certains évènement précis qui peuvent
survenir lors d'une partie. Les suivants~:

\begin{itemize}
    \item suppression d'un bonbon [\textbf{50 pts}]~;
    \item combinaison de 3 bonbons en ligne droite [\textbf{50 pts}]~;
    \item combinaison de 4 bonbons en ligne droite [\textbf{125 pts}]~;
    \item combinaison de 3 à 4 bonbons sur deux axes [\textbf{200 pts}]~;
    \item combinaison de 5 bonbons ou plus en ligne droite [\textbf{500 pts}]~;
\end{itemize}

\section{Conclusion}

Nous avons pu voir les différentes fonctionnalités que nous
avons ainsi que la manière de les avoir accomplies à
l'aide de l'héritage, l'encapsulation et le polymorphisme mais
aussi de beaucoup d'autres concepts du C++ moderne comme les
pointeurs intelligents ou les itérateurs. Ce fût une très
bonne expérience enrichissante de recréer ce jeu mythique et de voir les
différentes subtilités qu'il renferme ainsi que de trouver
des solutions aux problèmes qui sont survenus.

\end{document}
