%! TeX program = xelatex
%! TEX TS-program = xelatex
\documentclass[11pt,a4paper]{article}

% Language
\usepackage{polyglossia}
\setdefaultlanguage[frenchpart=false, frenchfootnote=true, frenchitemlabels=true]{french}
\usepackage{numprint}

% Fonts
\usepackage{fontspec}
\setmainfont{Linux Libertine O}
\setsansfont{Linux Biolinum O}
% \setmonofont{Linux Libertine Mono O}

\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{attachfile2}

\usepackage{fullpage}
\usepackage[parfill]{parskip}

\usepackage{xcolor}

%-----------------------------------------------------------

\newcommand{\up}[1]{\textsuperscript{#1}}
\newcommand{\down}[1]{\textsubscript{#1}}

\newcommand{\addcode}[3]{
	\begin{figure}[H]
		\centering
		\lstinputlisting[language=#2, caption=\textattachfile{#1}{#1}, label=#3]{#1}
	\end{figure}
}

\newcommand{\addimg}[4]{
	\begin{figure}[H]
		\centering
		\includegraphics[#2]{#1}
	\caption{#3}
	\label{#4}
	\end{figure}
}

\newcommand{\p}[1]{(p #1)}
\newcommand{\e}[2]{#1 \p{#2}}

%-----------------------------------------------------------

\definecolor{base}{RGB}{250,245,237}
\definecolor{subtle}{RGB}{110,107,135}
\definecolor{love}{RGB}{181,99,122}
\definecolor{gold}{RGB}{235,158,51}
\definecolor{rose}{RGB}{214,130,125}
\definecolor{pine}{RGB}{41,105,130}
\definecolor{foam}{RGB}{87,148,158}
\definecolor{iris}{RGB}{143,122,168}

\hypersetup{
	colorlinks=true,
		allcolors=iris
}
\attachfilesetup{color=iris}

%-----------------------------------------------------------

\lstset{
	% backgroundcolor=\color{white},        % background color
		basicstyle=\ttfamily,                   % regular style
		breakatwhitespace=true,                 % sets if automatic breaks should only happen at whitespace
		breaklines=true,                        % sets automatic line breaking
		captionpos=t,                           % caption-position
		commentstyle=\itshape\color{subtle},    % comment style
		% deletekeywords={...},                 % delete keywords from the given language
		escapeinside={\%*}{*)},                 % if you want to add LaTeX within your code
		firstnumber=1,                          % start line enumeration with line 1
		frame=tb,                               % adds a frame around the code
		keepspaces=true,                        % keeps spaces in text
		keywordstyle=\color{pine},              % keyword style
		language=C++,                           % language of the code
		% morekeywords={*,...},                 % add more keywords to the set
		numbers=left,                           % position of line-numbers; possible values are (none, left, right)
		numbersep=15pt,                         % distance between line-numbers and the code
		numberstyle=\scriptsize\ttfamily\color{subtle}, % style used for line-numbers
		% rulecolor=\color{black},              % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
		showspaces=false,                       % show spaces everywhere
		showstringspaces=false,                 % underline spaces within strings only
		showtabs=false,                         % show tabs within strings
		stepnumber=1,                           % step between two line-numbers
		stringstyle=\color{love},               % string literal style
		tabsize=4,	                          % default tabsize
		% title=\lstname                        % show the filename
}

%-----------------------------------------------------------

\title{Polygon Crush Saga}
\author{Alec Weinhofer \and Boris Petrov}
\date{\today}

\begin{document}
\maketitle
\tableofcontents

%-----------------------------------------------------------

\section{Introduction}

\emph{Candy Crush Saga}\footnote{\url{https://fr.wikipedia.org/wiki/Candy_Crush_Saga}}
cumule à ce jour plus de 2,7 milliards de
téléchargements. Un nombre faramineux. Cela le rend de fait
un des jeux les plus populaires de ces dernières années et
ce n'est évidemment pas dû au hasard. Derrière ce titre, se
cache un concept simple mais intelligent qui consiste à
former des combinaisons de bonbons pour les faire
disparaître afin de remplir des objectifs divers.

C'est donc ce concept simple sur papier (mais pas tellement
dans les faits) que nous avons essayé de répliquer pour ce
projet en utilisant des concepts d'orienté objet tels que
l'encapsulation ou encore l'héritage.

Pour ce qui est du rapport, nous allons d'abord commencer par donner un aperçu des
fonctionnalités que nous avons réussi à implémenter avant de
rentrer dans les détails d'implémentation.
Nous aborderons ensuite le calcul de notre score.

\section{Fonctionnalités}
% Pour toi Alec!

\section{Implémentation}
\subsection{Logique}
% Pour toi Alec!

\subsection{Classes}

Étant donné le grand nombre de classes de notre projet, nous
avons décidé de ne mettre que les plus importantes, celles
nécessaires pour bien comprendre le fonctionnement.

Nous avons également omis les méthodes intermédiaires
nécessaires pour recevoir une information d'un objet
\emph{C} depuis un objet \emph{B} telles que \verb@b.w()@ pour
éviter \verb@b.getWindow().w()@.

Pour ce qui est de la partie visuelle de notre jeu, nous
avons quelques classes de formes ainsi que des animations
qui peuvent leur être attachées. Celles-ci étant
principalement du code FLTK, nous avons décidé de ne pas les
inclure ici.

Les deux classes qui suivent sont la base de presque toutes
les autres classes de notre projet. Les héritiers de la
première sont interactifs et réagissent aux évènements
qu'ils implémentent alors que ceux de la deuxième peuvent
être dessinés sur l'écran. C'est un conteneur d'une forme et
d'une éventuelle animation.

\addcode{code/interactive.hpp}{C++}{}{}
\addcode{code/drawableContainer.hpp}{C++}{}{}

Deux autres classes basiques, sont celles implémentant le
pattern de l'observateur. Nous avons ainsi \verb@Observer@
et \verb@Subject@.

Nous avons ensuite la classe \verb@Game@ qui est le point
pivotant de notre programme. Elle décide quelle vue
afficher et contient le meilleur score.

Une vue dans notre programme est un écran que nous pouvons
avoir dans notre jeu. Ce sera par exemple l'écran de
chargement, le sélecteur de niveau ou encore un niveau
individuel (en exemple ci-dessous).

\addcode{code/game.hpp}{C++}{}{}

\addcode{code/view.hpp}{C++}{}{}
% \addcode{code/loadingScreen.hpp}{C++}{}{}
\addcode{code/level.hpp}{C++}{}{}
% \addcode{code/levelSelector.hpp}{C++}{}{}

Un niveau contient donc les données du niveau, une grille
et une barre de statut.

Les données sont stockées dans une instance de la classe
\verb@LevelData@. C'est en quelque sorte une classe
conteneur qui initialise ses données lors de sa construction
et possède des méthodes se limitant à des \emph{getters}.
Les données ne sont pas sensées être changées après la
construction.

La barre de statut est, quant à elle, plus intéressante.
Elle va se charger de deux aspects centraux de nos niveaux, le
comptage du score et l'objectif à atteindre.


\subsection{MVC}

Nous n'avons pas un architecture MVC en tant que telle, avec
les trois composants principaux, mais plutôt quelques éléments y
faisant référence.

Nous avons les états dans lesquels notre jeu
peut être. Le \verb@ReadyState@ par exemple a
lieu lorsqu'une action est attendue de la part du joueur, là
où le \verb@FallState@ est actif lorsque des bonbons sont
en train de tomber.

Le propre de chaque état est de réagir de manière différente
aux évènements tels que les clics de souris ou encore la
terminaison des animations. Ainsi par exemple, les clics de souris ne devraient
pas être considérés lorsque deux bonbons sont en train
d'être échangés.

Nous pouvons transposer les états du jeu aux Contrôleurs et la
grille qu'il contrôlent à la Vue et au Modèle.
Cette implémentation boiteuse vient principalement du fait
que nous avions conçu notre architecture avant d'avoir vu le
concept de MVC et nous avons essayé de l'implémenter trop
tard.

\subsection{Score}

Les calcul du score est, contrairement au jeu original, plutôt simple.
Il est mis à jour par certains évènement précis qui peuvent
survenir lors d'une partie. Les suivants~:

\begin{itemize}
    \item suppression d'un bonbon [\textbf{50 pts}]~;
    \item combinaison de 3 bonbons en ligne droite [\textbf{50 pts}]~;
    \item combinaison de 4 bonbons en ligne droite [\textbf{125 pts}]~;
    \item combinaison de 3 à 4 bonbons sur deux axes [\textbf{200 pts}]~;
    \item combinaison de 5 bonbons ou plus en ligne droite [\textbf{500 pts}]~;
\end{itemize}

\section{Conclusion}

\end{document}
